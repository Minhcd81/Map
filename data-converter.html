// data-converter.html - Tool chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu offline
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C√¥ng c·ª• chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu - Land Planning Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #f5f7fa;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #eee;
        }
        
        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #7f8c8d;
        }
        
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .tool-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 25px;
            transition: transform 0.3s ease, border-color 0.3s ease;
        }
        
        .tool-card:hover {
            transform: translateY(-5px);
            border-color: #007bff;
        }
        
        .tool-card h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .file-input {
            margin: 15px 0;
            padding: 12px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }
        
        .file-input:hover {
            border-color: #007bff;
        }
        
        .file-input input[type="file"] {
            display: none;
        }
        
        .btn {
            padding: 12px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s ease;
            margin: 5px;
        }
        
        .btn:hover {
            background: #0056b3;
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #6c757d;
        }
        
        .btn-success {
            background: #28a745;
        }
        
        .output-area {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .templates-section {
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #eee;
        }
        
        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .template-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #007bff;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .status-message {
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            display: none;
        }
        
        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .coordinate-converter {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .coord-input {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        
        .coord-input input {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        @media (max-width: 768px) {
            .tools-grid {
                grid-template-columns: 1fr;
            }
            
            .coord-input {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ†Ô∏è C√¥ng c·ª• chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu</h1>
            <p>Chuy·ªÉn ƒë·ªïi v√† chu·∫©n b·ªã d·ªØ li·ªáu cho B·∫£n ƒë·ªì Quy ho·∫°ch & Gi√° ƒë·∫•t</p>
        </div>

        <div class="tools-grid">
            <!-- Excel to GeoJSON Converter -->
            <div class="tool-card">
                <h3>üìä Excel ‚Üí GeoJSON</h3>
                <p>Chuy·ªÉn ƒë·ªïi file Excel/CSV c√≥ t·ªça ƒë·ªô th√†nh GeoJSON</p>
                
                <div class="file-input" onclick="document.getElementById('excelFile').click()">
                    <input type="file" id="excelFile" accept=".xlsx,.xls,.csv">
                    <p>üìÅ Click ƒë·ªÉ ch·ªçn file Excel/CSV</p>
                </div>
                
                <button class="btn" onclick="convertExcelToGeoJSON()">Chuy·ªÉn ƒë·ªïi</button>
                <button class="btn btn-secondary" onclick="downloadTemplate('excel')">T·∫£i template</button>
                
                <div class="progress-bar" style="display: none;">
                    <div class="progress-fill"></div>
                </div>
                
                <div class="status-message" id="excelStatus"></div>
                <div class="output-area" id="excelOutput" style="display: none;"></div>
            </div>

            <!-- Coordinate Converter -->
            <div class="tool-card">
                <h3>üß≠ Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô</h3>
                <p>Chuy·ªÉn ƒë·ªïi gi·ªØa c√°c h·ªá t·ªça ƒë·ªô kh√°c nhau</p>
                
                <div class="coordinate-converter">
                    <select id="fromCoordSystem">
                        <option value="wgs84">WGS84 (GPS)</option>
                        <option value="vn2000">VN2000</option>
                        <option value="utm">UTM Zone 48N</option>
                    </select>
                    
                    <div class="coord-input">
                        <input type="text" id="inputLat" placeholder="Vƒ© ƒë·ªô / Y">
                        <input type="text" id="inputLng" placeholder="Kinh ƒë·ªô / X">
                    </div>
                    
                    <button class="btn" onclick="convertCoordinates()">Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô</button>
                    
                    <div id="coordResult" class="output-area" style="display: none;"></div>
                </div>
            </div>

            <!-- Data Validator -->
            <div class="tool-card">
                <h3>‚úÖ Ki·ªÉm tra d·ªØ li·ªáu</h3>
                <p>X√°c th·ª±c v√† l√†m s·∫°ch d·ªØ li·ªáu tr∆∞·ªõc khi s·ª≠ d·ª•ng</p>
                
                <div class="file-input" onclick="document.getElementById('validateFile').click()">
                    <input type="file" id="validateFile" accept=".xlsx,.xls,.csv,.geojson,.json">
                    <p>üìÅ Click ƒë·ªÉ ch·ªçn file c·∫ßn ki·ªÉm tra</p>
                </div>
                
                <button class="btn" onclick="validateData()">Ki·ªÉm tra d·ªØ li·ªáu</button>
                
                <div id="validationResult" class="output-area" style="display: none;"></div>
            </div>

            <!-- Price Calculator -->
            <div class="tool-card">
                <h3>üí∞ T√≠nh to√°n gi√° ƒë·∫•t</h3>
                <p>C√¥ng c·ª• t√≠nh to√°n v√† ∆∞·ªõc l∆∞·ª£ng gi√° ƒë·∫•t</p>
                
                <div class="coord-input">
                    <input type="number" id="plotArea" placeholder="Di·ªán t√≠ch (m¬≤)">
                    <input type="number" id="pricePerSqm" placeholder="Gi√°/m¬≤ (VNƒê)">
                </div>
                
                <select id="landTypeCalc">
                    <option value="ODT">ƒê·∫•t ·ªü ƒë√¥ th·ªã (ODT)</option>
                    <option value="GT">Giao th√¥ng (GT)</option>
                    <option value="CV">C√¥ng vi√™n (CV)</option>
                    <option value="TM">Th∆∞∆°ng m·∫°i (TM)</option>
                    <option value="CC">C√¥ng c·ªông (CC)</option>
                </select>
                
                <button class="btn" onclick="calculatePrice()">T√≠nh to√°n</button>
                
                <div id="priceResult" class="output-area" style="display: none;"></div>
            </div>
        </div>

        <!-- Templates Section -->
        <div class="templates-section">
            <h2>üìã Templates & M·∫´u d·ªØ li·ªáu</h2>
            <p>T·∫£i c√°c file m·∫´u ƒë·ªÉ chu·∫©n b·ªã d·ªØ li·ªáu nhanh ch√≥ng</p>
            
            <div class="template-grid">
                <div class="template-card">
                    <h4>üìä Excel Template</h4>
                    <p>File Excel m·∫´u v·ªõi c·∫•u tr√∫c chu·∫©n</p>
                    <button class="btn btn-success" onclick="downloadTemplate('excel')">T·∫£i Excel</button>
                </div>
                
                <div class="template-card">
                    <h4>üìÑ CSV Template</h4>
                    <p>File CSV ƒë∆°n gi·∫£n v·ªõi d·ªØ li·ªáu m·∫´u</p>
                    <button class="btn btn-success" onclick="downloadTemplate('csv')">T·∫£i CSV</button>
                </div>
                
                <div class="template-card">
                    <h4>üó∫Ô∏è GeoJSON Sample</h4>
                    <p>File GeoJSON m·∫´u v·ªõi polygon</p>
                    <button class="btn btn-success" onclick="downloadTemplate('geojson')">T·∫£i GeoJSON</button>
                </div>
                
                <div class="template-card">
                    <h4>üìä Google Sheets</h4>
                    <p>Template Google Sheets s·∫µn s√†ng s·ª≠ d·ª•ng</p>
                    <button class="btn btn-success" onclick="openGoogleSheetsTemplate()">M·ªü Template</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        // Global variables
        let currentData = null;

        // Excel to GeoJSON Converter
        function convertExcelToGeoJSON() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];
            
            if (!file) {
                showMessage('excelStatus', 'Vui l√≤ng ch·ªçn file Excel/CSV', 'error');
                return;
            }
            
            showProgress(true);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let data;
                    
                    if (file.name.endsWith('.csv')) {
                        // Parse CSV
                        const csvText = e.target.result;
                        const results = Papa.parse(csvText, {
                            header: true,
                            skipEmptyLines: true,
                            dynamicTyping: true
                        });
                        data = results.data;
                    } else {
                        // Parse Excel
                        const workbook = XLSX.read(e.target.result, { type: 'array' });
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        data = XLSX.utils.sheet_to_json(firstSheet);
                    }
                    
                    // Convert to GeoJSON
                    const geojson = convertToGeoJSON(data);
                    
                    if (geojson.features.length === 0) {
                        showMessage('excelStatus', 'Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu t·ªça ƒë·ªô h·ª£p l·ªá', 'error');
                        return;
                    }
                    
                    // Display result
                    const output = document.getElementById('excelOutput');
                    output.style.display = 'block';
                    output.innerHTML = `
                        <h4>‚úÖ Chuy·ªÉn ƒë·ªïi th√†nh c√¥ng!</h4>
                        <p>T√¨m th·∫•y ${geojson.features.length} ƒëi·ªÉm d·ªØ li·ªáu</p>
                        <button class="btn btn-success" onclick="downloadGeoJSON()">T·∫£i xu·ªëng GeoJSON</button>
                        <button class="btn btn-secondary" onclick="previewGeoJSON()">Xem tr∆∞·ªõc</button>
                    `;
                    
                    currentData = geojson;
                    showMessage('excelStatus', `Chuy·ªÉn ƒë·ªïi th√†nh c√¥ng ${data.length} b·∫£n ghi`, 'success');
                    
                } catch (error) {
                    console.error('Conversion error:', error);
                    showMessage('excelStatus', 'L·ªói khi chuy·ªÉn ƒë·ªïi: ' + error.message, 'error');
                } finally {
                    showProgress(false);
                }
            };
            
            if (file.name.endsWith('.csv')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        // Convert tabular data to GeoJSON
        function convertToGeoJSON(data) {
            const features = data
                .filter(row => {
                    const lat = parseFloat(row.lat || row.latitude || row.Latitude || 0);
                    const lng = parseFloat(row.lng || row.longitude || row.Longitude || 0);
                    return !isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0;
                })
                .map((row, index) => {
                    const lat = parseFloat(row.lat || row.latitude || row.Latitude);
                    const lng = parseFloat(row.lng || row.longitude || row.Longitude);
                    
                    return {
                        type: 'Feature',
                        id: index,
                        properties: {
                            name: row.name || row.Name || row.plot_name || `ƒêi·ªÉm ${index + 1}`,
                            landType: row.landType || row.land_type || row.type || 'ODT',
                            area: parseFloat(row.area || row.Area || 0),
                            pricePerSqm: parseFloat(row.pricePerSqm || row.price_per_sqm || row.price || 0),
                            totalValue: parseFloat(row.totalValue || row.total_value || 0),
                            address: row.address || row.Address || '',
                            ward: row.ward || row.Ward || '',
                            district: row.district || row.District || '',
                            city: row.city || row.City || '',
                            ...row // Include all original properties
                        },
                        geometry: {
                            type: 'Point',
                            coordinates: [lng, lat]
                        }
                    };
                });

            return {
                type: 'FeatureCollection',
                features: features
            };
        }

        // Coordinate conversion (simplified)
        function convertCoordinates() {
            const fromSystem = document.getElementById('fromCoordSystem').value;
            const lat = parseFloat(document.getElementById('inputLat').value);
            const lng = parseFloat(document.getElementById('inputLng').value);
            
            if (isNaN(lat) || isNaN(lng)) {
                alert('Vui l√≤ng nh·∫≠p t·ªça ƒë·ªô h·ª£p l·ªá');
                return;
            }
            
            let result;
            
            // Simplified conversion (trong th·ª±c t·∫ø c·∫ßn s·ª≠ d·ª•ng th∆∞ vi·ªán chuy√™n d·ª•ng nh∆∞ proj4js)
            if (fromSystem === 'wgs84') {
                result = {
                    wgs84: { lat: lat, lng: lng },
                    decimal: { lat: lat.toFixed(6), lng: lng.toFixed(6) },
                    dms: convertToDMS(lat, lng)
                };
            } else {
                result = {
                    note: 'Chuy·ªÉn ƒë·ªïi t·ª´ ' + fromSystem + ' c·∫ßn th∆∞ vi·ªán chuy√™n d·ª•ng',
                    input: { lat: lat, lng: lng }
                };
            }
            
            const output = document.getElementById('coordResult');
            output.style.display = 'block';
            output.innerHTML = `
                <h4>K·∫øt qu·∫£ chuy·ªÉn ƒë·ªïi:</h4>
                <pre>${JSON.stringify(result, null, 2)}</pre>
            `;
        }

        // Convert decimal degrees to DMS
        function convertToDMS(lat, lng) {
            function toDMS(decimal, isLat) {
                const abs = Math.abs(decimal);
                const degrees = Math.floor(abs);
                const minutes = Math.floor((abs - degrees) * 60);
                const seconds = ((abs - degrees - minutes / 60) * 3600).toFixed(2);
                const direction = decimal >= 0 ? (isLat ? 'N' : 'E') : (isLat ? 'S' : 'W');
                return `${degrees}¬∞${minutes}'${seconds}"${direction}`;
            }
            
            return {
                latitude: toDMS(lat, true),
                longitude: toDMS(lng, false)
            };
        }

        // Data validation
        function validateData() {
            const fileInput = document.getElementById('validateFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Vui l√≤ng ch·ªçn file ƒë·ªÉ ki·ªÉm tra');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let data;
                    let errors = [];
                    let warnings = [];
                    
                    if (file.name.endsWith('.json') || file.name.endsWith('.geojson')) {
                        data = JSON.parse(e.target.result);
                        validateGeoJSON(data, errors, warnings);
                    } else if (file.name.endsWith('.csv')) {
                        const results = Papa.parse(e.target.result, { header: true });
                        data = results.data;
                        validateTabularData(data, errors, warnings);
                    } else {
                        const workbook = XLSX.read(e.target.result, { type: 'array' });
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        data = XLSX.utils.sheet_to_json(firstSheet);
                        validateTabularData(data, errors, warnings);
                    }
                    
                    displayValidationResults(errors, warnings, data);
                    
                } catch (error) {
                    const output = document.getElementById('validationResult');
                    output.style.display = 'block';
                    output.innerHTML = `<div class="status-error">L·ªói ƒë·ªçc file: ${error.message}</div>`;
                }
            };
            
            if (file.name.endsWith('.csv') || file.name.endsWith('.json') || file.name.endsWith('.geojson')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        // Validate GeoJSON
        function validateGeoJSON(geojson, errors, warnings) {
            if (!geojson.type || geojson.type !== 'FeatureCollection') {
                errors.push('File kh√¥ng ph·∫£i GeoJSON FeatureCollection h·ª£p l·ªá');
                return;
            }
            
            if (!geojson.features || !Array.isArray(geojson.features)) {
                errors.push('Kh√¥ng t√¨m th·∫•y m·∫£ng features');
                return;
            }
            
            geojson.features.forEach((feature, index) => {
                if (!feature.type || feature.type !== 'Feature') {
                    errors.push(`Feature ${index}: Thi·∫øu type='Feature'`);
                }
                
                if (!feature.geometry) {
                    errors.push(`Feature ${index}: Thi·∫øu geometry`);
                } else if (!['Point', 'Polygon', 'LineString'].includes(feature.geometry.type)) {
                    warnings.push(`Feature ${index}: Geometry type ${feature.geometry.type} kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ ƒë·∫ßy ƒë·ªß`);
                }
                
                if (!feature.properties) {
                    warnings.push(`Feature ${index}: Thi·∫øu properties`);
                } else {
                    const props = feature.properties;
                    if (!props.name && !props.plot_name) {
                        warnings.push(`Feature ${index}: Thi·∫øu t√™n (name ho·∫∑c plot_name)`);
                    }
                    if (!props.landType && !props.land_type) {
                        warnings.push(`Feature ${index}: Thi·∫øu lo·∫°i ƒë·∫•t (landType ho·∫∑c land_type)`);
                    }
                }
            });
        }

        // Validate tabular data
        function validateTabularData(data, errors, warnings) {
            if (!data || data.length === 0) {
                errors.push('File kh√¥ng ch·ª©a d·ªØ li·ªáu');
                return;
            }
            
            const firstRow = data[0];
            const requiredFields = ['name', 'latitude', 'longitude'];
            const recommendedFields = ['landType', 'area', 'pricePerSqm'];
            
            // Check required fields
            requiredFields.forEach(field => {
                const hasField = Object.keys(firstRow).some(key => 
                    key.toLowerCase().includes(field.toLowerCase())
                );
                
                if (!hasField) {
                    if (field === 'latitude') {
                        const hasLat = Object.keys(firstRow).some(key => 
                            key.toLowerCase().includes('lat')
                        );
                        if (!hasLat) errors.push(`Thi·∫øu c·ªôt t·ªça ƒë·ªô vƒ© ƒë·ªô (latitude/lat)`);
                    } else if (field === 'longitude') {
                        const hasLng = Object.keys(firstRow).some(key => 
                            key.toLowerCase().includes('lng') || key.toLowerCase().includes('lon')
                        );
                        if (!hasLng) errors.push(`Thi·∫øu c·ªôt t·ªça ƒë·ªô kinh ƒë·ªô (longitude/lng)`);
                    } else {
                        warnings.push(`Thi·∫øu c·ªôt: ${field}`);
                    }
                }
            });
            
            // Check data quality
            let validCoordCount = 0;
            data.forEach((row, index) => {
                const lat = parseFloat(row.lat || row.latitude || row.Latitude || 0);
                const lng = parseFloat(row.lng || row.longitude || row.Longitude || 0);
                
                if (!isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0) {
                    validCoordCount++;
                    
                    // Check coordinate ranges for Vietnam
                    if (lat < 8 || lat > 24 || lng < 102 || lng > 110) {
                        warnings.push(`H√†ng ${index + 1}: T·ªça ƒë·ªô c√≥ th·ªÉ kh√¥ng n·∫±m trong Vi·ªát Nam`);
                    }
                } else {
                    errors.push(`H√†ng ${index + 1}: T·ªça ƒë·ªô kh√¥ng h·ª£p l·ªá`);
                }
            });
            
            if (validCoordCount === 0) {
                errors.push('Kh√¥ng t√¨m th·∫•y t·ªça ƒë·ªô h·ª£p l·ªá n√†o');
            }
        }

        // Display validation results
        function displayValidationResults(errors, warnings, data) {
            const output = document.getElementById('validationResult');
            output.style.display = 'block';
            
            let html = '<h4>üìä K·∫øt qu·∫£ ki·ªÉm tra:</h4>';
            
            if (errors.length === 0 && warnings.length === 0) {
                html += '<div class="status-success">‚úÖ D·ªØ li·ªáu ho√†n to√†n h·ª£p l·ªá!</div>';
            }
            
            if (errors.length > 0) {
                html += '<div class="status-error"><h5>‚ùå L·ªói c·∫ßn s·ª≠a:</h5><ul>';
                errors.forEach(error => html += `<li>${error}</li>`);
                html += '</ul></div>';
            }
            
            if (warnings.length > 0) {
                html += '<div style="background: #fff3cd; color: #856404; padding: 10px; border-radius: 4px; margin: 10px 0;"><h5>‚ö†Ô∏è C·∫£nh b√°o:</h5><ul>';
                warnings.forEach(warning => html += `<li>${warning}</li>`);
                html += '</ul></div>';
            }
            
            // Summary
            const recordCount = Array.isArray(data) ? data.length : (data.features ? data.features.length : 0);
            html += `<div style="background: #e9ecef; padding: 10px; border-radius: 4px; margin: 10px 0;">
                <h5>üìã T√≥m t·∫Øt:</h5>
                <p>T·ªïng s·ªë b·∫£n ghi: ${recordCount}</p>
                <p>L·ªói: ${errors.length}</p>
                <p>C·∫£nh b√°o: ${warnings.length}</p>
            </div>`;
            
            output.innerHTML = html;
        }

        // Price calculation
        function calculatePrice() {
            const area = parseFloat(document.getElementById('plotArea').value);
            const pricePerSqm = parseFloat(document.getElementById('pricePerSqm').value);
            const landType = document.getElementById('landTypeCalc').value;
            
            if (isNaN(area) || isNaN(pricePerSqm) || area <= 0 || pricePerSqm <= 0) {
                alert('Vui l√≤ng nh·∫≠p di·ªán t√≠ch v√† gi√° h·ª£p l·ªá');
                return;
            }
            
            const totalValue = area * pricePerSqm;
            const priceInBillion = totalValue / 1000000000;
            const pricePerSqmInMillion = pricePerSqm / 1000000;
            
            // Land type multiplier (rough estimation)
            const multipliers = {
                'ODT': 1.0,   // Residential
                'TM': 1.5,    // Commercial  
                'GT': 0.3,    // Traffic
                'CV': 0.2,    // Park
                'CC': 0.4     // Public
            };
            
            const adjustedPrice = totalValue * (multipliers[landType] || 1.0);
            
            const result = document.getElementById('priceResult');
            result.style.display = 'block';
            result.innerHTML = `
                <h4>üí∞ K·∫øt qu·∫£ t√≠nh to√°n:</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 6px;">
                        <strong>Th√¥ng tin c∆° b·∫£n:</strong><br>
                        Di·ªán t√≠ch: ${area.toLocaleString()} m¬≤<br>
                        Gi√° g·ªëc: ${pricePerSqmInMillion.toFixed(2)} tri·ªáu/m¬≤<br>
                        Lo·∫°i ƒë·∫•t: ${landType}
                    </div>
                    <div style="background: #e8f5e9; padding: 15px; border-radius: 6px;">
                        <strong>Gi√° tr·ªã:</strong><br>
                        T·ªïng gi√° tr·ªã: ${priceInBillion.toFixed(2)} t·ª∑ VNƒê<br>
                        Sau ƒëi·ªÅu ch·ªânh: ${(adjustedPrice / 1000000000).toFixed(2)} t·ª∑ VNƒê<br>
                        H·ªá s·ªë: ${multipliers[landType] || 1.0}
                    </div>
                </div>
                <div style="background: #fff3cd; padding: 10px; border-radius: 4px; margin: 10px 0;">
                    <small><em>* Gi√° ƒë∆∞·ª£c ƒëi·ªÅu ch·ªânh theo lo·∫°i ƒë·∫•t v√† ch·ªâ mang t√≠nh tham kh·∫£o</em></small>
                </div>
            `;
        }

        // Download templates
        function downloadTemplate(type) {
            switch (type) {
                case 'excel':
                    downloadExcelTemplate();
                    break;
                case 'csv':
                    downloadCSVTemplate();
                    break;
                case 'geojson':
                    downloadGeoJSONTemplate();
                    break;
            }
        }

        function downloadExcelTemplate() {
            const data = [
                {
                    'name': 'Th·ª≠a 19 T·ªù 1',
                    'landType': 'ODT',
                    'area': 320.91,
                    'pricePerSqm': 26810000,
                    'totalValue': 8600000000,
                    'latitude': 10.7769,
                    'longitude': 106.6980,
                    'address': 'ƒê∆∞·ªùng ABC',
                    'ward': 'Ph∆∞·ªùng T√¢y Th·∫°nh',
                    'district': 'Qu·∫≠n T√¢n Ph√∫',
                    'city': 'TP.HCM'
                },
                {
                    'name': 'Th·ª≠a 22 T·ªù 1',
                    'landType': 'GT',
                    'area': 285.50,
                    'pricePerSqm': 18500000,
                    'totalValue': 5280000000,
                    'latitude': 10.7775,
                    'longitude': 106.6990,
                    'address': 'ƒê∆∞·ªùng DEF',
                    'ward': 'Ph∆∞·ªùng T√¢y Th·∫°nh',
                    'district': 'Qu·∫≠n T√¢n Ph√∫',
                    'city': 'TP.HCM'
                }
            ];
            
            const ws = XLSX.utils.json_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Land Data');
            
            XLSX.writeFile(wb, 'land_data_template.xlsx');
        }

        function downloadCSVTemplate() {
            const csvContent = `name,landType,area,pricePerSqm,totalValue,latitude,longitude,address,ward,district,city
"Th·ª≠a 19 T·ªù 1",ODT,320.91,26810000,8600000000,10.7769,106.6980,"ƒê∆∞·ªùng ABC","Ph∆∞·ªùng T√¢y Th·∫°nh","Qu·∫≠n T√¢n Ph√∫","TP.HCM"
"Th·ª≠a 22 T·ªù 1",GT,285.50,18500000,5280000000,10.7775,106.6990,"ƒê∆∞·ªùng DEF","Ph∆∞·ªùng T√¢y Th·∫°nh","Qu·∫≠n T√¢n Ph√∫","TP.HCM"`;
            
            downloadFile(csvContent, 'land_data_template.csv', 'text/csv');
        }

        function downloadGeoJSONTemplate() {
            const geojson = {
                "type": "FeatureCollection",
                "features": [
                    {
                        "type": "Feature",
                        "properties": {
                            "name": "Th·ª≠a 19 T·ªù 1",
                            "landType": "ODT",
                            "area": 320.91,
                            "pricePerSqm": 26810000,
                            "totalValue": 8600000000,
                            "address": "Ph∆∞·ªùng T√¢y Th·∫°nh, Qu·∫≠n T√¢n Ph√∫"
                        },
                        "geometry": {
                            "type": "Polygon",
                            "coordinates": [[
                                [106.6980, 10.7769],
                                [106.6985, 10.7770],
                                [106.6987, 10.7765],
                                [106.6982, 10.7764],
                                [106.6980, 10.7769]
                            ]]
                        }
                    }
                ]
            };
            
            downloadFile(JSON.stringify(geojson, null, 2), 'land_data_template.geojson', 'application/json');
        }

        function openGoogleSheetsTemplate() {
            window.open('https://docs.google.com/spreadsheets/d/1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms/copy', '_blank');
        }

        // Download current GeoJSON
        function downloadGeoJSON() {
            if (!currentData) {
                alert('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ t·∫£i xu·ªëng');
                return;
            }
            
            downloadFile(JSON.stringify(currentData, null, 2), 'converted_data.geojson', 'application/json');
        }

        // Preview GeoJSON
        function previewGeoJSON() {
            if (!currentData) {
                alert('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xem tr∆∞·ªõc');
                return;
            }
            
            const previewWindow = window.open('', '_blank', 'width=800,height=600');
            previewWindow.document.write(`
                <html>
                <head><title>GeoJSON Preview</title></head>
                <body style="font-family: monospace; padding: 20px;">
                    <h2>GeoJSON Preview</h2>
                    <pre style="background: #f5f5f5; padding: 15px; overflow: auto;">
${JSON.stringify(currentData, null, 2)}
                    </pre>
                </body>
                </html>
            `);
        }

        // Utility functions
        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.className = `status-message status-${type}`;
            element.textContent = message;
            element.style.display = 'block';
            
            setTimeout(() => {
                element.style.display = 'none';
            }, 5000);
        }

        function showProgress(show) {
            const progressBar = document.querySelector('.progress-bar');
            if (show) {
                progressBar.style.display = 'block';
                progressBar.querySelector('.progress-fill').style.width = '100%';
            } else {
                setTimeout(() => {
                    progressBar.style.display = 'none';
                    progressBar.querySelector('.progress-fill').style.width = '0%';
                }, 500);
            }
        }
    </script>
</body>
</html>

---

# batch-process.py - Python script for batch processing shapefiles
import os
import sys
import json
import geopandas as gpd
import pandas as pd
from pathlib import Path

def convert_shapefile_to_geojson(shapefile_path, output_path=None):
    """
    Convert shapefile to GeoJSON format
    """
    try:
        # Read shapefile
        gdf = gpd.read_file(shapefile_path)
        
        # Set output path if not provided
        if output_path is None:
            output_path = shapefile_path.replace('.shp', '.geojson')
        
        # Convert to WGS84 if not already
        if gdf.crs != 'EPSG:4326':
            print(f"Converting CRS from {gdf.crs} to EPSG:4326")
            gdf = gdf.to_crs('EPSG:4326')
        
        # Clean column names
        gdf.columns = [col.lower().replace(' ', '_') for col in gdf.columns]
        
        # Add standard fields if missing
        if 'name' not in gdf.columns:
            if 'plot_name' in gdf.columns:
                gdf['name'] = gdf['plot_name']
            else:
                gdf['name'] = gdf.index.astype(str)
        
        if 'land_type' not in gdf.columns:
            gdf['land_type'] = 'ODT'
        
        # Save as GeoJSON
        gdf.to_file(output_path, driver='GeoJSON', encoding='utf-8')
        
        print(f"‚úÖ Converted {shapefile_path} to {output_path}")
        print(f"   Features: {len(gdf)}")
        print(f"   CRS: {gdf.crs}")
        
        return output_path
        
    except Exception as e:
        print(f"‚ùå Error converting {shapefile_path}: {str(e)}")
        return None

def batch_convert_shapefiles(input_dir, output_dir=None):
    """
    Convert all shapefiles in a directory to GeoJSON
    """
    input_path = Path(input_dir)
    
    if output_dir:
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
    else:
        output_path = input_path
    
    # Find all shapefiles
    shapefiles = list(input_path.glob('*.shp'))
    
    if not shapefiles:
        print("‚ùå No shapefiles found in the directory")
        return
    
    print(f"üîç Found {len(shapefiles)} shapefiles")
    
    results = []
    for shapefile in shapefiles:
        output_file = output_path / f"{shapefile.stem}.geojson"
        result = convert_shapefile_to_geojson(str(shapefile), str(output_file))
        if result:
            results.append(result)
    
    print(f"‚úÖ Successfully converted {len(results)} files")
    return results

def merge_geojson_files(file_list, output_path):
    """
    Merge multiple GeoJSON files into one
    """
    try:
        all_features = []
        
        for file_path in file_list:
            with open(file_path, 'r', encoding='utf-8') as f:
                geojson = json.load(f)
                
            if 'features' in geojson:
                all_features.extend(geojson['features'])
        
        # Create merged GeoJSON
        merged = {
            "type": "FeatureCollection",
            "features": all_features
        }
        
        # Save merged file
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(merged, f, ensure_ascii=False, indent=2)
        
        print(f"‚úÖ Merged {len(file_list)} files into {output_path}")
        print(f"   Total features: {len(all_features)}")
        
    except Exception as e:
        print(f"‚ùå Error merging files: {str(e)}")

def add_price_data_to_geojson(geojson_path, price_csv_path, output_path):
    """
    Add price data from CSV to GeoJSON features
    """
    try:
        # Read GeoJSON
        gdf = gpd.read_file(geojson_path)
        
        # Read price data
        price_df = pd.read_csv(price_csv_path)
        
        # Merge data based on name or coordinates
        if 'name' in gdf.columns and 'name' in price_df.columns:
            merged = gdf.merge(price_df, on='name', how='left')
        else:
            print("‚ö†Ô∏è Cannot match features with price data")
            return None
        
        # Save enhanced GeoJSON
        merged.to_file(output_path, driver='GeoJSON', encoding='utf-8')
        
        print(f"‚úÖ Added price data to {output_path}")
        return output_path
        
    except Exception as e:
        print(f"‚ùå Error adding price data: {str(e)}")
        return None

def validate_geojson(file_path):
    """
    Validate GeoJSON file structure and data quality
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        errors = []
        warnings = []
        
        # Check basic structure
        if data.get('type') != 'FeatureCollection':
            errors.append("Not a valid FeatureCollection")
            return errors, warnings
        
        features = data.get('features', [])
        
        if not features:
            errors.append("No features found")
            return errors, warnings
        
        # Check each feature
        for i, feature in enumerate(features):
            if feature.get('type') != 'Feature':
                errors.append(f"Feature {i}: Invalid type")
            
            if not feature.get('geometry'):
                errors.append(f"Feature {i}: Missing geometry")
            
            properties = feature.get('properties', {})
            if not properties.get('name'):
                warnings.append(f"Feature {i}: Missing name")
            
            # Check coordinates for Vietnam bounds
            if feature.get('geometry', {}).get('type') == 'Point':
                coords = feature['geometry']['coordinates']
                lng, lat = coords[0], coords[1]
                
                if not (102 <= lng <= 110 and 8 <= lat <= 24):
                    warnings.append(f"Feature {i}: Coordinates may be outside Vietnam")
        
        print(f"‚úÖ Validation complete for {file_path}")
        print(f"   Features: {len(features)}")
        print(f"   Errors: {len(errors)}")
        print(f"   Warnings: {len(warnings)}")
        
        if errors:
            print("‚ùå Errors:")
            for error in errors:
                print(f"   - {error}")
        
        if warnings:
            print("‚ö†Ô∏è Warnings:")
            for warning in warnings:
                print(f"   - {warning}")
        
        return errors, warnings
        
    except Exception as e:
        print(f"‚ùå Error validating {file_path}: {str(e)}")
        return [str(e)], []

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("""
Usage:
    python batch-process.py convert <shapefile_path> [output_path]
    python batch-process.py batch <input_directory> [output_directory]
    python batch-process.py merge <file1> <file2> ... <output_file>
    python batch-process.py validate <geojson_file>
    python batch-process.py add-prices <geojson_file> <price_csv> <output_file>
        """)
        sys.exit(1)
    
    command = sys.argv[1]
    
    if command == "convert":
        if len(sys.argv) < 3:
            print("‚ùå Please provide shapefile path")
            sys.exit(1)
        
        shapefile_path = sys.argv[2]
        output_path = sys.argv[3] if len(sys.argv) > 3 else None
        convert_shapefile_to_geojson(shapefile_path, output_path)
    
    elif command == "batch":
        if len(sys.argv) < 3:
            print("‚ùå Please provide input directory")
            sys.exit(1)
        
        input_dir = sys.argv[2]
        output_dir = sys.argv[3] if len(sys.argv) > 3 else None
        batch_convert_shapefiles(input_dir, output_dir)
    
    elif command == "merge":
        if len(sys.argv) < 4:
            print("‚ùå Please provide at least 2 files and output path")
            sys.exit(1)
        
        files = sys.argv[2:-1]
        output = sys.argv[-1]
        merge_geojson_files(files, output)
    
    elif command == "validate":
        if len(sys.argv) < 3:
            print("‚ùå Please provide GeoJSON file path")
            sys.exit(1)
        
        validate_geojson(sys.argv[2])
    
    elif command == "add-prices":
        if len(sys.argv) < 5:
            print("‚ùå Please provide geojson_file, price_csv, and output_file")
            sys.exit(1)
        
        add_price_data_to_geojson(sys.argv[2], sys.argv[3], sys.argv[4])
    
    else:
        print(f"‚ùå Unknown command: {command}")
        sys.exit(1)